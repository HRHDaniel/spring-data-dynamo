# Spring Data Dynamo
The primary goal of the [Spring Data](http://projects.spring.io/spring-data) project is to make it easier to build Spring-powered applications that use new data access technologies such as non-relational databases, map-reduce frameworks, and cloud based data services.

The Spring Data Dynamo project aims to provide a familiar and consistent Spring-based programming model while working with Amazon's DynamoDB.

## Quick Start

### Build Dependency
Currently this project is not released or pushed into maven central, so you will have to build from source and add to your repository or reference locally from your build project.

### Spring Data repositories
To simplify the creation of data repositories Spring Data Dynamo provides a generic repository programming model. It will automatically create a repository proxy for you that adds implementations of finder methods you specify on an interface.

For example, given the following `Person` class with first and last name properties, a `PersonRepository` interface that can query for `Person` by last name and when the first name starts with a string is shown below:

```java
@DynamoDBTable(tableName = "Person")
public class Person {
  @Id
  @DynamoDBHashKey
  @DynamoDBAutoGeneratedKey
  private id;
  private firstName;
  private lastName;
  
  // ... Getters/Setters omitted...
}
```

```java
public interface PersonRepository extends DynamoRepository<Person, Long> {

  List<Person> findByLastname(String lastname);

  List<Person> findByFirstnameStartsWith(String firstname);
}
```

The queries issued on execution will be derived from the method name.  DynamoRepository also provides the default methods from the Spring CrudRepository so that you can easily save and find single entities and collections of them.

You can have Spring automatically create a proxy for the interface by using the following JavaConfig:

```java
@Configuration
@EnableDynamoRepositories
class ApplicationConfig {

  @Bean
  public AWSCredentialsProvider awsCredentailsProvider() {
    return new DefaultAWSCredentialsProviderChain();
  }

  @Bean
  public DynamoDBMapper dynamoDBMapper() {
    return new DynamoDBMapper(amazonDynamoDB());
  }
}
```

This will find the repository interface and register a proxy object in the container. You can use it as shown below:

```java
@Service
public class MyService {

  private final PersonRepository repository;

  @Autowired
  public MyService(PersonRepository repository) {
    this.repository = repository;
  }

  public void doWork() {
     repository.deleteAll();

     Person person = new Person();
     person.setFirstname("Oliver");
     person.setLastname("Gierke");
     person = repository.save(person);

     List<Person> lastNameResults = repository.findByLastname("Gierke");
     List<Person> firstNameResults = repository.findByFirstnameStartsWith("Oli");
  }
}
```

### Composite Keys
DynamoDB allows for a composite key, madeup of a HashKey and a RangeKey (aka sort key).  As spring data only allows for a single key object, for tables using both keys as a composite key, the repository key in Spring needs to use a `DynamoCompositeKey` object to wrap these keys.

Your Person object then becomes:

```java
@DynamoDBTable(tableName = "Person")
public class Person {

    @Id
    @JsonIgnore
    @DynamoDBIgnore
    private final DynamoCompositeKey<String, String> id;

    public Person() {
        id = new DynamoCompositeKey<>();
    }
    
    @DynamoDBHashKey
    public String getLastname() {
        return id.getHashKey();
    }
    
    public void setLastname(String lastname) {
        id.setHashKey(lastname);
    }
    
    @DynamoDBRangeKey
    public String getFirstname() {
        return id.getRangeKey();
    }
    
    public void setFirstname(String firstname) {
        id.setRangeKey(firstname);
    }
}
```
And your repository is implemented as:
```java
public interface PersonRepository extends DynamoRepository<Person, DynamoCompositeKey<String, String>> {

  List<Person> findByLastname(String lastname);

  List<Person> findByFirstnameStartsWith(String firstname);
}
```

### Global Secondary Indexes
Global Secondary Indexes are used by providing the annotation `@DynamoGlobalSecondaryIndex` on the repository method.

```java
public interface PersonRepository extends DynamoRepository<Person, DynamoCompositeKey<String, String>> {

  @DynamoGlobalSecondaryIndex(hashKeyName="firstname", indexName="firstnameindex")
  List<Person> findByFirstname(String firstname);
}
```

### Scans Vs. Queries
Spring Data Dynamo will determine whether or not the operation needs to perform a scan or a query.  Scans can be very inefficient and costly compared to queries.  Multiple operations in the base methods use scans, such as `findAll`, `count`, `deleteAll`, (In general, any operation that operates on an unknown list of hashKeys).

Whether or not a dynamic method uses a query or a scan can be seen by setting the `DEBUG` level for the logger `com.github.hrhdaniel.data.dynamodb.query.criteria`.  In addition to displaying the actual query sent to Amazon, if Spring Data Dynamo chooses to do a scan, the debug information will include a description of why a scan was necessary.
```
Executing Dynamo Scan with Filter [attribute_exists ( nested.childName )] Index [null].  Scanning due to [No HashKey condition found]
Executing Dynamo Query with Key Condition [hashKey = :c0v0] Filter [null] Index [testindex]
```
